import math
from collections import deque
import copy

NUM_CLASSES_IN_CLASSIFIER = 2
CLASSIFIER_BUFFER_LEN = 30
CLASSIFIER_CONFIDENCE_SCORE = 0.6
MIN_CLASSIFICATION_VELOCITY = 0.3
TAG_HISTORY_LEN = 5
MAX_NUM_UNKNOWN_TAGS_FOR_HUMAN_DETECTION = 1
MAX_NUM_TRACKS = 20 # This could vary depending on the configuration file. Use 20 here as a safe likely maximum to ensure there's enough memory for the classifier

class ClassificationSupplement():
    def __init__(self):
        # Hold the track IDs detected in the current frame
        self.trackIDsInCurrFrame = []
        self.classifierOutput = None
        self.tracks = None
        self.classifierTags = [deque([0] * TAG_HISTORY_LEN, maxlen = TAG_HISTORY_LEN) for i in range(MAX_NUM_TRACKS)]
        self.tracksIDsInPreviousFrame = []
        self.wasTargetHuman = [0 for i in range(MAX_NUM_TRACKS)]
        
    def run_frame(self, outputDict):
        # Hold the track IDs detected in the current frame
        trackIDsInCurrFrame = []
        classifierOutput = None
        tracks = None
        if ('classifierOutput' in outputDict):
            classifierOutput = outputDict['classifierOutput']
        if ('trackData' in outputDict):
            tracks = outputDict['trackData']
        if (classifierOutput is not None and tracks is not None):
            # Allocate label for each track
            outputDict['ClassificationDecision'] = [None] * MAX_NUM_TRACKS
            # Loop through the tracks detected to label them as human/non-human
            for trackNum, trackName in enumerate(tracks):
                # Decode trackID from the trackName
                trackID = int(trackName[0])
                # Hold the track IDs detected in the current frame
                trackIDsInCurrFrame.append(trackID)
                # Track Velocity (radial) = (x * v_x + y*v_y + z*v_z)/ r
                trackVelocity = (trackName[1] * trackName[4] + trackName[2] * trackName[5] + trackName[3] * trackName[6]) \
                / math.sqrt(math.pow(trackName[1], 2) + math.pow(trackName[2], 2) + math.pow(trackName[3], 2))
                
                # Update the tags if ((classification probabilities have been generated by the radar for the current frame) AND 
                # (either the target has not already been detected as a human or the doppler is above the minimum velocity for classification)). 
                # This is designed to stop the tags from being assigned if target has already been detected as a human and becomes stationary.
                if(classifierOutput[trackNum][0] != 0.5 and not(self.wasTargetHuman[trackID] == 1 and abs(trackVelocity)<MIN_CLASSIFICATION_VELOCITY)):
                    # See if either label is above the minimum score needed for classification, it so, add the corresponding tag to the buffer
                    for label in range(NUM_CLASSES_IN_CLASSIFIER):
                        if(classifierOutput[trackNum][label] > CLASSIFIER_CONFIDENCE_SCORE):
                            self.classifierTags[trackID].appendleft(-1 if label == 0 else 1)
                
                # Recompute sum of tags and number of unknown tags
                # Sum the Tags (composed of +1 for one label, -1 for the other label and 0 for unknown) to see which label is dominant
                sumOfTags = sum(self.classifierTags[trackID])
                # Count the number of times there is an unknown tag in the tag buffer
                numUnknownTags = sum(1 for i in self.classifierTags[trackID] if i == 0)

                ## Assign Labels
                # If we don't have enough tags for a decision or the number of tags for human/nonhuman are equal, make no decision 
                if(numUnknownTags > MAX_NUM_UNKNOWN_TAGS_FOR_HUMAN_DETECTION or sumOfTags == 0):
                    self.wasTargetHuman[trackID] = 0 # Target was NOT detected to be human in the current frame, save for next frame
                    outputDict['ClassificationDecision'][trackID] = "Unknown Label"
                # If we have enough tags and the majority of them are for nonhuman, then detect nonhuman
                elif(sumOfTags < 0):
                    self.wasTargetHuman[trackID] = 0 # Target was NOT detected to be human in the current frame, save for next frame
                    outputDict['ClassificationDecision'][trackID] = "Non-Human"
                # If we have enough tags and the majority of them are for human, then detect human
                elif(sumOfTags > 0):
                    self.wasTargetHuman[trackID] = 1 # Target WAS detected to be human in the current frame, save for next frame
                    outputDict['ClassificationDecision'][trackID] = "Human"

        # Regardless of whether you get tracks in the current frame, if there were tracks in the previous frame, reset the
        # tag buffer and wasHumanTarget flag for tracks that aren't detected in the current frame but were detected in the previous frame
        tracksToShuffle = set(self.tracksIDsInPreviousFrame) - set(trackIDsInCurrFrame)
        for track in tracksToShuffle:
            for frame in range(TAG_HISTORY_LEN):
                self.classifierTags[track].appendleft(0) # fill the buffer with zeros to remove any history for the track
            self.wasTargetHuman[track] = 0 # Since target was not detected in current frame, reset the wasTargetHuman flag

        # Put the current tracks detected into the previous track list for the next frame
        self.tracksIDsInPreviousFrame = copy.deepcopy(trackIDsInCurrFrame)